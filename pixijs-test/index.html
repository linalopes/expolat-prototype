<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PixiJS SimplePlane – 4x4 grid with 4 draggable corners</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/pixi.js@7/dist/pixi.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background: #111; }
    #info {
      position: fixed; left: 12px; top: 10px; color: #fff; font: 14px/1.4 system-ui, sans-serif;
      background: rgba(0,0,0,.4); padding: 8px 10px; border-radius: 8px;
    }
  </style>
</head>
<body>
<div id="info">
  <b>SimplePlane Warp (6x8 grid, 4 control points)</b><br/>
  • File: <code>Prime.png</code> in project root<br/>
  • Drag a green dot (corner) to deform the image<br/>
  • R = reset mesh
</div>
<script>
(async function () {
  const app = new PIXI.Application({
    antialias: true,
    backgroundAlpha: 1,
    backgroundColor: 0xffffff,
    resizeTo: window
  });
  document.body.appendChild(app.view);

  const texture = await PIXI.Assets.load('Prime.png');
  const stage = app.stage;

  // --- SimplePlane with 6x8 vertices ---
  const COLS = 6, ROWS = 8;
  const plane = new PIXI.SimplePlane(texture, COLS, ROWS);
  const planeContainer = new PIXI.Container();
  stage.addChild(planeContainer);
  planeContainer.addChild(plane);

  function layout() {
    const w = app.renderer.width;
    const h = app.renderer.height;
    const sx = w / texture.width;
    const sy = h / texture.height;
    const s = Math.min(sx, sy) * 0.9;
    planeContainer.scale.set(s);
    planeContainer.x = (w - texture.width * s) / 2;
    planeContainer.y = (h - texture.height * s) / 2;
  }
  layout();
  window.addEventListener('resize', layout);

  const posBuffer = plane.geometry.getBuffer('aVertexPosition');

  // --- Only 4 control points: corners ---
  const controlIndices = [14, 15, 26, 27];
  const dots = {};
  const labels = {}; // Pre-created text labels to prevent WebGL context loss
  let draggingIndex = -1;
  let hoverIndex = -1;

  const dotRadius = 8, hitRadius = 18;

  function createDot(i) {
    const g = new PIXI.Graphics();
    g.zIndex = 10;
    stage.addChild(g);
    dots[i] = g;

    // Pre-create text label once to avoid creating new PIXI.Text every frame
    // This prevents WebGL context loss from continuous GPU texture allocation
    const label = new PIXI.Text(`P${i}`, {
      fontFamily: 'system-ui, sans-serif',
      fontSize: 12,
      fill: 0xffffff
    });
    label.anchor.set(0.5, 1.8);
    g.addChild(label);
    labels[i] = label;
  }
  controlIndices.forEach(createDot);

  // --- Pointer interactions ---
  app.stage.eventMode = 'static';
  app.stage.hitArea = app.screen;

  app.stage.on('pointerdown', (e) => {
    const idx = pickVertex(e);
    if (idx !== -1) {
      draggingIndex = idx;
      app.stage.cursor = 'grabbing';
    }
  });

  app.stage.on('pointermove', (e) => {
    hoverIndex = pickVertex(e);
    if (draggingIndex !== -1) {
      const local = e.data.getLocalPosition(plane);
      setVertex(draggingIndex, local.x, local.y);
      posBuffer.update();
    } else {
      app.stage.cursor = (hoverIndex !== -1) ? 'grab' : 'default';
    }
  });

  app.stage.on('pointerup', () => {
    draggingIndex = -1;
    app.stage.cursor = (hoverIndex !== -1) ? 'grab' : 'default';
  });
  app.stage.on('pointerupoutside', () => {
    draggingIndex = -1;
    app.stage.cursor = (hoverIndex !== -1) ? 'grab' : 'default';
  });

  // Reset with R
  window.addEventListener('keydown', (ev) => {
    if (ev.key.toLowerCase() === 'r') {
      resetMesh();
      posBuffer.update();
    }
  });

  // --- Utilities ---
  function getVertex(i) {
    const ix = i * 2;
    return { x: posBuffer.data[ix], y: posBuffer.data[ix + 1] };
  }
  function setVertex(i, x, y) {
    const ix = i * 2;
    posBuffer.data[ix] = x;
    posBuffer.data[ix + 1] = y;
  }

  function pickVertex(e) {
    const gpos = e.data.global;
    let best = -1, bestDist = Infinity;
    controlIndices.forEach((i) => {
      const v = getVertex(i);
      const world = plane.toGlobal(new PIXI.Point(v.x, v.y));
      const d = Math.hypot(world.x - gpos.x, world.y - gpos.y);
      if (d < bestDist) { best = i; bestDist = d; }
    });
    return (bestDist <= hitRadius) ? best : -1;
  }

  function resetMesh() {
    // Fill positions row-major
    let idx = 0;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        setVertex(idx, (c / (COLS - 1)) * texture.width, (r / (ROWS - 1)) * texture.height);
        idx++;
      }
    }
  }
  resetMesh();

  // --- Render loop: draw control dots ---
  app.ticker.add(() => {
    controlIndices.forEach((i) => {
      const v = getVertex(i);
      const p = plane.toGlobal(new PIXI.Point(v.x, v.y));
      const g = dots[i];
      g.clear();

      if (i === hoverIndex) {
        g.lineStyle(2, 0x33ff99, 0.8).beginFill(0x33ff99, 0.08);
        g.drawCircle(p.x, p.y, hitRadius);
        g.endFill();
      }

      const fill = (i === draggingIndex) ? 0xffff33 : 0x33ff66;
      g.lineStyle(2, 0x0, 0.8).beginFill(fill, 1);
      g.drawCircle(p.x, p.y, dotRadius);
      g.endFill();

      // Update pre-created label position instead of creating new PIXI.Text
      // This prevents WebGL context loss from continuous GPU texture allocation
      const label = labels[i];
      label.position.set(p.x, p.y);
    });
  });
})();
</script>
</body>
</html>
